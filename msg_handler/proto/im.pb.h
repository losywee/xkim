// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: im.proto

#ifndef PROTOBUF_im_2eproto__INCLUDED
#define PROTOBUF_im_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace im {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_im_2eproto();
void protobuf_AssignDesc_im_2eproto();
void protobuf_ShutdownFile_im_2eproto();

class ImTouch;
class ImTouchResponse;
class ImMsg;
class ImMsgAck;
class ImAuthRequest;
class ImAuthResponse;
class ImPackContent;
class ImPack;

enum ImMsgType {
  IM_TXT = 1,
  IM_PIC = 2,
  IM_VDO = 3
};
bool ImMsgType_IsValid(int value);
const ImMsgType ImMsgType_MIN = IM_TXT;
const ImMsgType ImMsgType_MAX = IM_VDO;
const int ImMsgType_ARRAYSIZE = ImMsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImMsgType_descriptor();
inline const ::std::string& ImMsgType_Name(ImMsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImMsgType_descriptor(), value);
}
inline bool ImMsgType_Parse(
    const ::std::string& name, ImMsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImMsgType>(
    ImMsgType_descriptor(), name, value);
}
enum ImMsgLogicType {
  IM_REQUEST = 1,
  IM_RESPONSE = 2
};
bool ImMsgLogicType_IsValid(int value);
const ImMsgLogicType ImMsgLogicType_MIN = IM_REQUEST;
const ImMsgLogicType ImMsgLogicType_MAX = IM_RESPONSE;
const int ImMsgLogicType_ARRAYSIZE = ImMsgLogicType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImMsgLogicType_descriptor();
inline const ::std::string& ImMsgLogicType_Name(ImMsgLogicType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImMsgLogicType_descriptor(), value);
}
inline bool ImMsgLogicType_Parse(
    const ::std::string& name, ImMsgLogicType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImMsgLogicType>(
    ImMsgLogicType_descriptor(), name, value);
}
enum ImPackType {
  IM_UNKNOW = 0,
  IM_TOUCH = 1,
  IM_TOUCH_ACK = 2,
  IM_MSG = 3,
  IM_MSG_ACK = 4,
  IM_AUTH = 5,
  IM_AUTH_RESPONSE = 6
};
bool ImPackType_IsValid(int value);
const ImPackType ImPackType_MIN = IM_UNKNOW;
const ImPackType ImPackType_MAX = IM_AUTH_RESPONSE;
const int ImPackType_ARRAYSIZE = ImPackType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImPackType_descriptor();
inline const ::std::string& ImPackType_Name(ImPackType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImPackType_descriptor(), value);
}
inline bool ImPackType_Parse(
    const ::std::string& name, ImPackType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImPackType>(
    ImPackType_descriptor(), name, value);
}
// ===================================================================

class ImTouch : public ::google::protobuf::Message {
 public:
  ImTouch();
  virtual ~ImTouch();

  ImTouch(const ImTouch& from);

  inline ImTouch& operator=(const ImTouch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImTouch& default_instance();

  void Swap(ImTouch* other);

  // implements Message ----------------------------------------------

  ImTouch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImTouch& from);
  void MergeFrom(const ImTouch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:im.ImTouch)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static ImTouch* default_instance_;
};
// -------------------------------------------------------------------

class ImTouchResponse : public ::google::protobuf::Message {
 public:
  ImTouchResponse();
  virtual ~ImTouchResponse();

  ImTouchResponse(const ImTouchResponse& from);

  inline ImTouchResponse& operator=(const ImTouchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImTouchResponse& default_instance();

  void Swap(ImTouchResponse* other);

  // implements Message ----------------------------------------------

  ImTouchResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImTouchResponse& from);
  void MergeFrom(const ImTouchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:im.ImTouchResponse)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static ImTouchResponse* default_instance_;
};
// -------------------------------------------------------------------

class ImMsg : public ::google::protobuf::Message {
 public:
  ImMsg();
  virtual ~ImMsg();

  ImMsg(const ImMsg& from);

  inline ImMsg& operator=(const ImMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImMsg& default_instance();

  void Swap(ImMsg* other);

  // implements Message ----------------------------------------------

  ImMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImMsg& from);
  void MergeFrom(const ImMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // required int32 seq = 2;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 2;
  inline ::google::protobuf::int32 seq() const;
  inline void set_seq(::google::protobuf::int32 value);

  // repeated int32 target_uid = 3;
  inline int target_uid_size() const;
  inline void clear_target_uid();
  static const int kTargetUidFieldNumber = 3;
  inline ::google::protobuf::int32 target_uid(int index) const;
  inline void set_target_uid(int index, ::google::protobuf::int32 value);
  inline void add_target_uid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      target_uid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_target_uid();

  // required .im.ImMsgLogicType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::im::ImMsgLogicType type() const;
  inline void set_type(::im::ImMsgLogicType value);

  // optional bytes msg_id = 5;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 5;
  inline const ::std::string& msg_id() const;
  inline void set_msg_id(const ::std::string& value);
  inline void set_msg_id(const char* value);
  inline void set_msg_id(const void* value, size_t size);
  inline ::std::string* mutable_msg_id();
  inline ::std::string* release_msg_id();
  inline void set_allocated_msg_id(::std::string* msg_id);

  // optional float points = 6;
  inline bool has_points() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 6;
  inline float points() const;
  inline void set_points(float value);

  // optional int32 timeout = 7;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 7;
  inline ::google::protobuf::int32 timeout() const;
  inline void set_timeout(::google::protobuf::int32 value);

  // optional bytes text_content = 8;
  inline bool has_text_content() const;
  inline void clear_text_content();
  static const int kTextContentFieldNumber = 8;
  inline const ::std::string& text_content() const;
  inline void set_text_content(const ::std::string& value);
  inline void set_text_content(const char* value);
  inline void set_text_content(const void* value, size_t size);
  inline ::std::string* mutable_text_content();
  inline ::std::string* release_text_content();
  inline void set_allocated_text_content(::std::string* text_content);

  // optional string pic_id = 9;
  inline bool has_pic_id() const;
  inline void clear_pic_id();
  static const int kPicIdFieldNumber = 9;
  inline const ::std::string& pic_id() const;
  inline void set_pic_id(const ::std::string& value);
  inline void set_pic_id(const char* value);
  inline void set_pic_id(const char* value, size_t size);
  inline ::std::string* mutable_pic_id();
  inline ::std::string* release_pic_id();
  inline void set_allocated_pic_id(::std::string* pic_id);

  // optional string vid_id = 10;
  inline bool has_vid_id() const;
  inline void clear_vid_id();
  static const int kVidIdFieldNumber = 10;
  inline const ::std::string& vid_id() const;
  inline void set_vid_id(const ::std::string& value);
  inline void set_vid_id(const char* value);
  inline void set_vid_id(const char* value, size_t size);
  inline ::std::string* mutable_vid_id();
  inline ::std::string* release_vid_id();
  inline void set_allocated_vid_id(::std::string* vid_id);

  // optional bytes loc_word = 11;
  inline bool has_loc_word() const;
  inline void clear_loc_word();
  static const int kLocWordFieldNumber = 11;
  inline const ::std::string& loc_word() const;
  inline void set_loc_word(const ::std::string& value);
  inline void set_loc_word(const char* value);
  inline void set_loc_word(const void* value, size_t size);
  inline ::std::string* mutable_loc_word();
  inline ::std::string* release_loc_word();
  inline void set_allocated_loc_word(::std::string* loc_word);

  // @@protoc_insertion_point(class_scope:im.ImMsg)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_points();
  inline void clear_has_points();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_text_content();
  inline void clear_has_text_content();
  inline void set_has_pic_id();
  inline void clear_has_pic_id();
  inline void set_has_vid_id();
  inline void clear_has_vid_id();
  inline void set_has_loc_word();
  inline void clear_has_loc_word();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 seq_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > target_uid_;
  ::std::string* msg_id_;
  int type_;
  float points_;
  ::std::string* text_content_;
  ::std::string* pic_id_;
  ::std::string* vid_id_;
  ::std::string* loc_word_;
  ::google::protobuf::int32 timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static ImMsg* default_instance_;
};
// -------------------------------------------------------------------

class ImMsgAck : public ::google::protobuf::Message {
 public:
  ImMsgAck();
  virtual ~ImMsgAck();

  ImMsgAck(const ImMsgAck& from);

  inline ImMsgAck& operator=(const ImMsgAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImMsgAck& default_instance();

  void Swap(ImMsgAck* other);

  // implements Message ----------------------------------------------

  ImMsgAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImMsgAck& from);
  void MergeFrom(const ImMsgAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes msg_id = 1;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 1;
  inline const ::std::string& msg_id() const;
  inline void set_msg_id(const ::std::string& value);
  inline void set_msg_id(const char* value);
  inline void set_msg_id(const void* value, size_t size);
  inline ::std::string* mutable_msg_id();
  inline ::std::string* release_msg_id();
  inline void set_allocated_msg_id(::std::string* msg_id);

  // required int32 seq = 2;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 2;
  inline ::google::protobuf::int32 seq() const;
  inline void set_seq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:im.ImMsgAck)
 private:
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_seq();
  inline void clear_has_seq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msg_id_;
  ::google::protobuf::int32 seq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static ImMsgAck* default_instance_;
};
// -------------------------------------------------------------------

class ImAuthRequest : public ::google::protobuf::Message {
 public:
  ImAuthRequest();
  virtual ~ImAuthRequest();

  ImAuthRequest(const ImAuthRequest& from);

  inline ImAuthRequest& operator=(const ImAuthRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImAuthRequest& default_instance();

  void Swap(ImAuthRequest* other);

  // implements Message ----------------------------------------------

  ImAuthRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImAuthRequest& from);
  void MergeFrom(const ImAuthRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // required string token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:im.ImAuthRequest)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;
  ::google::protobuf::int32 uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static ImAuthRequest* default_instance_;
};
// -------------------------------------------------------------------

class ImAuthResponse : public ::google::protobuf::Message {
 public:
  ImAuthResponse();
  virtual ~ImAuthResponse();

  ImAuthResponse(const ImAuthResponse& from);

  inline ImAuthResponse& operator=(const ImAuthResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImAuthResponse& default_instance();

  void Swap(ImAuthResponse* other);

  // implements Message ----------------------------------------------

  ImAuthResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImAuthResponse& from);
  void MergeFrom(const ImAuthResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required bool auth_success = 2;
  inline bool has_auth_success() const;
  inline void clear_auth_success();
  static const int kAuthSuccessFieldNumber = 2;
  inline bool auth_success() const;
  inline void set_auth_success(bool value);

  // @@protoc_insertion_point(class_scope:im.ImAuthResponse)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_auth_success();
  inline void clear_has_auth_success();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;
  bool auth_success_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static ImAuthResponse* default_instance_;
};
// -------------------------------------------------------------------

class ImPackContent : public ::google::protobuf::Message {
 public:
  ImPackContent();
  virtual ~ImPackContent();

  ImPackContent(const ImPackContent& from);

  inline ImPackContent& operator=(const ImPackContent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImPackContent& default_instance();

  void Swap(ImPackContent* other);

  // implements Message ----------------------------------------------

  ImPackContent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImPackContent& from);
  void MergeFrom(const ImPackContent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .im.ImTouch touch = 1;
  inline bool has_touch() const;
  inline void clear_touch();
  static const int kTouchFieldNumber = 1;
  inline const ::im::ImTouch& touch() const;
  inline ::im::ImTouch* mutable_touch();
  inline ::im::ImTouch* release_touch();
  inline void set_allocated_touch(::im::ImTouch* touch);

  // optional .im.ImTouchResponse touch_rep = 2;
  inline bool has_touch_rep() const;
  inline void clear_touch_rep();
  static const int kTouchRepFieldNumber = 2;
  inline const ::im::ImTouchResponse& touch_rep() const;
  inline ::im::ImTouchResponse* mutable_touch_rep();
  inline ::im::ImTouchResponse* release_touch_rep();
  inline void set_allocated_touch_rep(::im::ImTouchResponse* touch_rep);

  // optional .im.ImMsg msg = 3;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 3;
  inline const ::im::ImMsg& msg() const;
  inline ::im::ImMsg* mutable_msg();
  inline ::im::ImMsg* release_msg();
  inline void set_allocated_msg(::im::ImMsg* msg);

  // optional .im.ImMsgAck msg_ack = 4;
  inline bool has_msg_ack() const;
  inline void clear_msg_ack();
  static const int kMsgAckFieldNumber = 4;
  inline const ::im::ImMsgAck& msg_ack() const;
  inline ::im::ImMsgAck* mutable_msg_ack();
  inline ::im::ImMsgAck* release_msg_ack();
  inline void set_allocated_msg_ack(::im::ImMsgAck* msg_ack);

  // optional .im.ImAuthRequest auth_req = 5;
  inline bool has_auth_req() const;
  inline void clear_auth_req();
  static const int kAuthReqFieldNumber = 5;
  inline const ::im::ImAuthRequest& auth_req() const;
  inline ::im::ImAuthRequest* mutable_auth_req();
  inline ::im::ImAuthRequest* release_auth_req();
  inline void set_allocated_auth_req(::im::ImAuthRequest* auth_req);

  // optional .im.ImAuthResponse auth_rep = 6;
  inline bool has_auth_rep() const;
  inline void clear_auth_rep();
  static const int kAuthRepFieldNumber = 6;
  inline const ::im::ImAuthResponse& auth_rep() const;
  inline ::im::ImAuthResponse* mutable_auth_rep();
  inline ::im::ImAuthResponse* release_auth_rep();
  inline void set_allocated_auth_rep(::im::ImAuthResponse* auth_rep);

  // @@protoc_insertion_point(class_scope:im.ImPackContent)
 private:
  inline void set_has_touch();
  inline void clear_has_touch();
  inline void set_has_touch_rep();
  inline void clear_has_touch_rep();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_msg_ack();
  inline void clear_has_msg_ack();
  inline void set_has_auth_req();
  inline void clear_has_auth_req();
  inline void set_has_auth_rep();
  inline void clear_has_auth_rep();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::im::ImTouch* touch_;
  ::im::ImTouchResponse* touch_rep_;
  ::im::ImMsg* msg_;
  ::im::ImMsgAck* msg_ack_;
  ::im::ImAuthRequest* auth_req_;
  ::im::ImAuthResponse* auth_rep_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static ImPackContent* default_instance_;
};
// -------------------------------------------------------------------

class ImPack : public ::google::protobuf::Message {
 public:
  ImPack();
  virtual ~ImPack();

  ImPack(const ImPack& from);

  inline ImPack& operator=(const ImPack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImPack& default_instance();

  void Swap(ImPack* other);

  // implements Message ----------------------------------------------

  ImPack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImPack& from);
  void MergeFrom(const ImPack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .im.ImPackType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::im::ImPackType type() const;
  inline void set_type(::im::ImPackType value);

  // required .im.ImPackContent content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::im::ImPackContent& content() const;
  inline ::im::ImPackContent* mutable_content();
  inline ::im::ImPackContent* release_content();
  inline void set_allocated_content(::im::ImPackContent* content);

  // optional int32 ts = 3;
  inline bool has_ts() const;
  inline void clear_ts();
  static const int kTsFieldNumber = 3;
  inline ::google::protobuf::int32 ts() const;
  inline void set_ts(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:im.ImPack)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_ts();
  inline void clear_has_ts();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::im::ImPackContent* content_;
  int type_;
  ::google::protobuf::int32 ts_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static ImPack* default_instance_;
};
// ===================================================================


// ===================================================================

// ImTouch

// required int32 uid = 1;
inline bool ImTouch::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImTouch::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImTouch::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImTouch::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 ImTouch::uid() const {
  return uid_;
}
inline void ImTouch::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// -------------------------------------------------------------------

// ImTouchResponse

// required int32 uid = 1;
inline bool ImTouchResponse::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImTouchResponse::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImTouchResponse::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImTouchResponse::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 ImTouchResponse::uid() const {
  return uid_;
}
inline void ImTouchResponse::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// -------------------------------------------------------------------

// ImMsg

// required int32 uid = 1;
inline bool ImMsg::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImMsg::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImMsg::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImMsg::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 ImMsg::uid() const {
  return uid_;
}
inline void ImMsg::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// required int32 seq = 2;
inline bool ImMsg::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImMsg::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImMsg::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImMsg::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 ImMsg::seq() const {
  return seq_;
}
inline void ImMsg::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
}

// repeated int32 target_uid = 3;
inline int ImMsg::target_uid_size() const {
  return target_uid_.size();
}
inline void ImMsg::clear_target_uid() {
  target_uid_.Clear();
}
inline ::google::protobuf::int32 ImMsg::target_uid(int index) const {
  return target_uid_.Get(index);
}
inline void ImMsg::set_target_uid(int index, ::google::protobuf::int32 value) {
  target_uid_.Set(index, value);
}
inline void ImMsg::add_target_uid(::google::protobuf::int32 value) {
  target_uid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ImMsg::target_uid() const {
  return target_uid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ImMsg::mutable_target_uid() {
  return &target_uid_;
}

// required .im.ImMsgLogicType type = 4;
inline bool ImMsg::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImMsg::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImMsg::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImMsg::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::im::ImMsgLogicType ImMsg::type() const {
  return static_cast< ::im::ImMsgLogicType >(type_);
}
inline void ImMsg::set_type(::im::ImMsgLogicType value) {
  assert(::im::ImMsgLogicType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bytes msg_id = 5;
inline bool ImMsg::has_msg_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImMsg::set_has_msg_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImMsg::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImMsg::clear_msg_id() {
  if (msg_id_ != &::google::protobuf::internal::kEmptyString) {
    msg_id_->clear();
  }
  clear_has_msg_id();
}
inline const ::std::string& ImMsg::msg_id() const {
  return *msg_id_;
}
inline void ImMsg::set_msg_id(const ::std::string& value) {
  set_has_msg_id();
  if (msg_id_ == &::google::protobuf::internal::kEmptyString) {
    msg_id_ = new ::std::string;
  }
  msg_id_->assign(value);
}
inline void ImMsg::set_msg_id(const char* value) {
  set_has_msg_id();
  if (msg_id_ == &::google::protobuf::internal::kEmptyString) {
    msg_id_ = new ::std::string;
  }
  msg_id_->assign(value);
}
inline void ImMsg::set_msg_id(const void* value, size_t size) {
  set_has_msg_id();
  if (msg_id_ == &::google::protobuf::internal::kEmptyString) {
    msg_id_ = new ::std::string;
  }
  msg_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImMsg::mutable_msg_id() {
  set_has_msg_id();
  if (msg_id_ == &::google::protobuf::internal::kEmptyString) {
    msg_id_ = new ::std::string;
  }
  return msg_id_;
}
inline ::std::string* ImMsg::release_msg_id() {
  clear_has_msg_id();
  if (msg_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_id_;
    msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ImMsg::set_allocated_msg_id(::std::string* msg_id) {
  if (msg_id_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_id_;
  }
  if (msg_id) {
    set_has_msg_id();
    msg_id_ = msg_id;
  } else {
    clear_has_msg_id();
    msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float points = 6;
inline bool ImMsg::has_points() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImMsg::set_has_points() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImMsg::clear_has_points() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImMsg::clear_points() {
  points_ = 0;
  clear_has_points();
}
inline float ImMsg::points() const {
  return points_;
}
inline void ImMsg::set_points(float value) {
  set_has_points();
  points_ = value;
}

// optional int32 timeout = 7;
inline bool ImMsg::has_timeout() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ImMsg::set_has_timeout() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ImMsg::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ImMsg::clear_timeout() {
  timeout_ = 0;
  clear_has_timeout();
}
inline ::google::protobuf::int32 ImMsg::timeout() const {
  return timeout_;
}
inline void ImMsg::set_timeout(::google::protobuf::int32 value) {
  set_has_timeout();
  timeout_ = value;
}

// optional bytes text_content = 8;
inline bool ImMsg::has_text_content() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ImMsg::set_has_text_content() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ImMsg::clear_has_text_content() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ImMsg::clear_text_content() {
  if (text_content_ != &::google::protobuf::internal::kEmptyString) {
    text_content_->clear();
  }
  clear_has_text_content();
}
inline const ::std::string& ImMsg::text_content() const {
  return *text_content_;
}
inline void ImMsg::set_text_content(const ::std::string& value) {
  set_has_text_content();
  if (text_content_ == &::google::protobuf::internal::kEmptyString) {
    text_content_ = new ::std::string;
  }
  text_content_->assign(value);
}
inline void ImMsg::set_text_content(const char* value) {
  set_has_text_content();
  if (text_content_ == &::google::protobuf::internal::kEmptyString) {
    text_content_ = new ::std::string;
  }
  text_content_->assign(value);
}
inline void ImMsg::set_text_content(const void* value, size_t size) {
  set_has_text_content();
  if (text_content_ == &::google::protobuf::internal::kEmptyString) {
    text_content_ = new ::std::string;
  }
  text_content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImMsg::mutable_text_content() {
  set_has_text_content();
  if (text_content_ == &::google::protobuf::internal::kEmptyString) {
    text_content_ = new ::std::string;
  }
  return text_content_;
}
inline ::std::string* ImMsg::release_text_content() {
  clear_has_text_content();
  if (text_content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_content_;
    text_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ImMsg::set_allocated_text_content(::std::string* text_content) {
  if (text_content_ != &::google::protobuf::internal::kEmptyString) {
    delete text_content_;
  }
  if (text_content) {
    set_has_text_content();
    text_content_ = text_content;
  } else {
    clear_has_text_content();
    text_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pic_id = 9;
inline bool ImMsg::has_pic_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ImMsg::set_has_pic_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ImMsg::clear_has_pic_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ImMsg::clear_pic_id() {
  if (pic_id_ != &::google::protobuf::internal::kEmptyString) {
    pic_id_->clear();
  }
  clear_has_pic_id();
}
inline const ::std::string& ImMsg::pic_id() const {
  return *pic_id_;
}
inline void ImMsg::set_pic_id(const ::std::string& value) {
  set_has_pic_id();
  if (pic_id_ == &::google::protobuf::internal::kEmptyString) {
    pic_id_ = new ::std::string;
  }
  pic_id_->assign(value);
}
inline void ImMsg::set_pic_id(const char* value) {
  set_has_pic_id();
  if (pic_id_ == &::google::protobuf::internal::kEmptyString) {
    pic_id_ = new ::std::string;
  }
  pic_id_->assign(value);
}
inline void ImMsg::set_pic_id(const char* value, size_t size) {
  set_has_pic_id();
  if (pic_id_ == &::google::protobuf::internal::kEmptyString) {
    pic_id_ = new ::std::string;
  }
  pic_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImMsg::mutable_pic_id() {
  set_has_pic_id();
  if (pic_id_ == &::google::protobuf::internal::kEmptyString) {
    pic_id_ = new ::std::string;
  }
  return pic_id_;
}
inline ::std::string* ImMsg::release_pic_id() {
  clear_has_pic_id();
  if (pic_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pic_id_;
    pic_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ImMsg::set_allocated_pic_id(::std::string* pic_id) {
  if (pic_id_ != &::google::protobuf::internal::kEmptyString) {
    delete pic_id_;
  }
  if (pic_id) {
    set_has_pic_id();
    pic_id_ = pic_id;
  } else {
    clear_has_pic_id();
    pic_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string vid_id = 10;
inline bool ImMsg::has_vid_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ImMsg::set_has_vid_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ImMsg::clear_has_vid_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ImMsg::clear_vid_id() {
  if (vid_id_ != &::google::protobuf::internal::kEmptyString) {
    vid_id_->clear();
  }
  clear_has_vid_id();
}
inline const ::std::string& ImMsg::vid_id() const {
  return *vid_id_;
}
inline void ImMsg::set_vid_id(const ::std::string& value) {
  set_has_vid_id();
  if (vid_id_ == &::google::protobuf::internal::kEmptyString) {
    vid_id_ = new ::std::string;
  }
  vid_id_->assign(value);
}
inline void ImMsg::set_vid_id(const char* value) {
  set_has_vid_id();
  if (vid_id_ == &::google::protobuf::internal::kEmptyString) {
    vid_id_ = new ::std::string;
  }
  vid_id_->assign(value);
}
inline void ImMsg::set_vid_id(const char* value, size_t size) {
  set_has_vid_id();
  if (vid_id_ == &::google::protobuf::internal::kEmptyString) {
    vid_id_ = new ::std::string;
  }
  vid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImMsg::mutable_vid_id() {
  set_has_vid_id();
  if (vid_id_ == &::google::protobuf::internal::kEmptyString) {
    vid_id_ = new ::std::string;
  }
  return vid_id_;
}
inline ::std::string* ImMsg::release_vid_id() {
  clear_has_vid_id();
  if (vid_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vid_id_;
    vid_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ImMsg::set_allocated_vid_id(::std::string* vid_id) {
  if (vid_id_ != &::google::protobuf::internal::kEmptyString) {
    delete vid_id_;
  }
  if (vid_id) {
    set_has_vid_id();
    vid_id_ = vid_id;
  } else {
    clear_has_vid_id();
    vid_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes loc_word = 11;
inline bool ImMsg::has_loc_word() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ImMsg::set_has_loc_word() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ImMsg::clear_has_loc_word() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ImMsg::clear_loc_word() {
  if (loc_word_ != &::google::protobuf::internal::kEmptyString) {
    loc_word_->clear();
  }
  clear_has_loc_word();
}
inline const ::std::string& ImMsg::loc_word() const {
  return *loc_word_;
}
inline void ImMsg::set_loc_word(const ::std::string& value) {
  set_has_loc_word();
  if (loc_word_ == &::google::protobuf::internal::kEmptyString) {
    loc_word_ = new ::std::string;
  }
  loc_word_->assign(value);
}
inline void ImMsg::set_loc_word(const char* value) {
  set_has_loc_word();
  if (loc_word_ == &::google::protobuf::internal::kEmptyString) {
    loc_word_ = new ::std::string;
  }
  loc_word_->assign(value);
}
inline void ImMsg::set_loc_word(const void* value, size_t size) {
  set_has_loc_word();
  if (loc_word_ == &::google::protobuf::internal::kEmptyString) {
    loc_word_ = new ::std::string;
  }
  loc_word_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImMsg::mutable_loc_word() {
  set_has_loc_word();
  if (loc_word_ == &::google::protobuf::internal::kEmptyString) {
    loc_word_ = new ::std::string;
  }
  return loc_word_;
}
inline ::std::string* ImMsg::release_loc_word() {
  clear_has_loc_word();
  if (loc_word_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = loc_word_;
    loc_word_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ImMsg::set_allocated_loc_word(::std::string* loc_word) {
  if (loc_word_ != &::google::protobuf::internal::kEmptyString) {
    delete loc_word_;
  }
  if (loc_word) {
    set_has_loc_word();
    loc_word_ = loc_word;
  } else {
    clear_has_loc_word();
    loc_word_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ImMsgAck

// optional bytes msg_id = 1;
inline bool ImMsgAck::has_msg_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImMsgAck::set_has_msg_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImMsgAck::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImMsgAck::clear_msg_id() {
  if (msg_id_ != &::google::protobuf::internal::kEmptyString) {
    msg_id_->clear();
  }
  clear_has_msg_id();
}
inline const ::std::string& ImMsgAck::msg_id() const {
  return *msg_id_;
}
inline void ImMsgAck::set_msg_id(const ::std::string& value) {
  set_has_msg_id();
  if (msg_id_ == &::google::protobuf::internal::kEmptyString) {
    msg_id_ = new ::std::string;
  }
  msg_id_->assign(value);
}
inline void ImMsgAck::set_msg_id(const char* value) {
  set_has_msg_id();
  if (msg_id_ == &::google::protobuf::internal::kEmptyString) {
    msg_id_ = new ::std::string;
  }
  msg_id_->assign(value);
}
inline void ImMsgAck::set_msg_id(const void* value, size_t size) {
  set_has_msg_id();
  if (msg_id_ == &::google::protobuf::internal::kEmptyString) {
    msg_id_ = new ::std::string;
  }
  msg_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImMsgAck::mutable_msg_id() {
  set_has_msg_id();
  if (msg_id_ == &::google::protobuf::internal::kEmptyString) {
    msg_id_ = new ::std::string;
  }
  return msg_id_;
}
inline ::std::string* ImMsgAck::release_msg_id() {
  clear_has_msg_id();
  if (msg_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_id_;
    msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ImMsgAck::set_allocated_msg_id(::std::string* msg_id) {
  if (msg_id_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_id_;
  }
  if (msg_id) {
    set_has_msg_id();
    msg_id_ = msg_id;
  } else {
    clear_has_msg_id();
    msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 seq = 2;
inline bool ImMsgAck::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImMsgAck::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImMsgAck::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImMsgAck::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 ImMsgAck::seq() const {
  return seq_;
}
inline void ImMsgAck::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
}

// -------------------------------------------------------------------

// ImAuthRequest

// required int32 uid = 1;
inline bool ImAuthRequest::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImAuthRequest::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImAuthRequest::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImAuthRequest::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 ImAuthRequest::uid() const {
  return uid_;
}
inline void ImAuthRequest::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// required string token = 2;
inline bool ImAuthRequest::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImAuthRequest::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImAuthRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImAuthRequest::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ImAuthRequest::token() const {
  return *token_;
}
inline void ImAuthRequest::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ImAuthRequest::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ImAuthRequest::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImAuthRequest::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ImAuthRequest::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ImAuthRequest::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ImAuthResponse

// required string token = 1;
inline bool ImAuthResponse::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImAuthResponse::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImAuthResponse::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImAuthResponse::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ImAuthResponse::token() const {
  return *token_;
}
inline void ImAuthResponse::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ImAuthResponse::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ImAuthResponse::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImAuthResponse::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ImAuthResponse::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ImAuthResponse::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool auth_success = 2;
inline bool ImAuthResponse::has_auth_success() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImAuthResponse::set_has_auth_success() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImAuthResponse::clear_has_auth_success() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImAuthResponse::clear_auth_success() {
  auth_success_ = false;
  clear_has_auth_success();
}
inline bool ImAuthResponse::auth_success() const {
  return auth_success_;
}
inline void ImAuthResponse::set_auth_success(bool value) {
  set_has_auth_success();
  auth_success_ = value;
}

// -------------------------------------------------------------------

// ImPackContent

// optional .im.ImTouch touch = 1;
inline bool ImPackContent::has_touch() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImPackContent::set_has_touch() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImPackContent::clear_has_touch() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImPackContent::clear_touch() {
  if (touch_ != NULL) touch_->::im::ImTouch::Clear();
  clear_has_touch();
}
inline const ::im::ImTouch& ImPackContent::touch() const {
  return touch_ != NULL ? *touch_ : *default_instance_->touch_;
}
inline ::im::ImTouch* ImPackContent::mutable_touch() {
  set_has_touch();
  if (touch_ == NULL) touch_ = new ::im::ImTouch;
  return touch_;
}
inline ::im::ImTouch* ImPackContent::release_touch() {
  clear_has_touch();
  ::im::ImTouch* temp = touch_;
  touch_ = NULL;
  return temp;
}
inline void ImPackContent::set_allocated_touch(::im::ImTouch* touch) {
  delete touch_;
  touch_ = touch;
  if (touch) {
    set_has_touch();
  } else {
    clear_has_touch();
  }
}

// optional .im.ImTouchResponse touch_rep = 2;
inline bool ImPackContent::has_touch_rep() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImPackContent::set_has_touch_rep() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImPackContent::clear_has_touch_rep() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImPackContent::clear_touch_rep() {
  if (touch_rep_ != NULL) touch_rep_->::im::ImTouchResponse::Clear();
  clear_has_touch_rep();
}
inline const ::im::ImTouchResponse& ImPackContent::touch_rep() const {
  return touch_rep_ != NULL ? *touch_rep_ : *default_instance_->touch_rep_;
}
inline ::im::ImTouchResponse* ImPackContent::mutable_touch_rep() {
  set_has_touch_rep();
  if (touch_rep_ == NULL) touch_rep_ = new ::im::ImTouchResponse;
  return touch_rep_;
}
inline ::im::ImTouchResponse* ImPackContent::release_touch_rep() {
  clear_has_touch_rep();
  ::im::ImTouchResponse* temp = touch_rep_;
  touch_rep_ = NULL;
  return temp;
}
inline void ImPackContent::set_allocated_touch_rep(::im::ImTouchResponse* touch_rep) {
  delete touch_rep_;
  touch_rep_ = touch_rep;
  if (touch_rep) {
    set_has_touch_rep();
  } else {
    clear_has_touch_rep();
  }
}

// optional .im.ImMsg msg = 3;
inline bool ImPackContent::has_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImPackContent::set_has_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImPackContent::clear_has_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImPackContent::clear_msg() {
  if (msg_ != NULL) msg_->::im::ImMsg::Clear();
  clear_has_msg();
}
inline const ::im::ImMsg& ImPackContent::msg() const {
  return msg_ != NULL ? *msg_ : *default_instance_->msg_;
}
inline ::im::ImMsg* ImPackContent::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) msg_ = new ::im::ImMsg;
  return msg_;
}
inline ::im::ImMsg* ImPackContent::release_msg() {
  clear_has_msg();
  ::im::ImMsg* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline void ImPackContent::set_allocated_msg(::im::ImMsg* msg) {
  delete msg_;
  msg_ = msg;
  if (msg) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
}

// optional .im.ImMsgAck msg_ack = 4;
inline bool ImPackContent::has_msg_ack() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImPackContent::set_has_msg_ack() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImPackContent::clear_has_msg_ack() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImPackContent::clear_msg_ack() {
  if (msg_ack_ != NULL) msg_ack_->::im::ImMsgAck::Clear();
  clear_has_msg_ack();
}
inline const ::im::ImMsgAck& ImPackContent::msg_ack() const {
  return msg_ack_ != NULL ? *msg_ack_ : *default_instance_->msg_ack_;
}
inline ::im::ImMsgAck* ImPackContent::mutable_msg_ack() {
  set_has_msg_ack();
  if (msg_ack_ == NULL) msg_ack_ = new ::im::ImMsgAck;
  return msg_ack_;
}
inline ::im::ImMsgAck* ImPackContent::release_msg_ack() {
  clear_has_msg_ack();
  ::im::ImMsgAck* temp = msg_ack_;
  msg_ack_ = NULL;
  return temp;
}
inline void ImPackContent::set_allocated_msg_ack(::im::ImMsgAck* msg_ack) {
  delete msg_ack_;
  msg_ack_ = msg_ack;
  if (msg_ack) {
    set_has_msg_ack();
  } else {
    clear_has_msg_ack();
  }
}

// optional .im.ImAuthRequest auth_req = 5;
inline bool ImPackContent::has_auth_req() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImPackContent::set_has_auth_req() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImPackContent::clear_has_auth_req() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImPackContent::clear_auth_req() {
  if (auth_req_ != NULL) auth_req_->::im::ImAuthRequest::Clear();
  clear_has_auth_req();
}
inline const ::im::ImAuthRequest& ImPackContent::auth_req() const {
  return auth_req_ != NULL ? *auth_req_ : *default_instance_->auth_req_;
}
inline ::im::ImAuthRequest* ImPackContent::mutable_auth_req() {
  set_has_auth_req();
  if (auth_req_ == NULL) auth_req_ = new ::im::ImAuthRequest;
  return auth_req_;
}
inline ::im::ImAuthRequest* ImPackContent::release_auth_req() {
  clear_has_auth_req();
  ::im::ImAuthRequest* temp = auth_req_;
  auth_req_ = NULL;
  return temp;
}
inline void ImPackContent::set_allocated_auth_req(::im::ImAuthRequest* auth_req) {
  delete auth_req_;
  auth_req_ = auth_req;
  if (auth_req) {
    set_has_auth_req();
  } else {
    clear_has_auth_req();
  }
}

// optional .im.ImAuthResponse auth_rep = 6;
inline bool ImPackContent::has_auth_rep() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImPackContent::set_has_auth_rep() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImPackContent::clear_has_auth_rep() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImPackContent::clear_auth_rep() {
  if (auth_rep_ != NULL) auth_rep_->::im::ImAuthResponse::Clear();
  clear_has_auth_rep();
}
inline const ::im::ImAuthResponse& ImPackContent::auth_rep() const {
  return auth_rep_ != NULL ? *auth_rep_ : *default_instance_->auth_rep_;
}
inline ::im::ImAuthResponse* ImPackContent::mutable_auth_rep() {
  set_has_auth_rep();
  if (auth_rep_ == NULL) auth_rep_ = new ::im::ImAuthResponse;
  return auth_rep_;
}
inline ::im::ImAuthResponse* ImPackContent::release_auth_rep() {
  clear_has_auth_rep();
  ::im::ImAuthResponse* temp = auth_rep_;
  auth_rep_ = NULL;
  return temp;
}
inline void ImPackContent::set_allocated_auth_rep(::im::ImAuthResponse* auth_rep) {
  delete auth_rep_;
  auth_rep_ = auth_rep;
  if (auth_rep) {
    set_has_auth_rep();
  } else {
    clear_has_auth_rep();
  }
}

// -------------------------------------------------------------------

// ImPack

// required .im.ImPackType type = 1;
inline bool ImPack::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImPack::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImPack::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImPack::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::im::ImPackType ImPack::type() const {
  return static_cast< ::im::ImPackType >(type_);
}
inline void ImPack::set_type(::im::ImPackType value) {
  assert(::im::ImPackType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .im.ImPackContent content = 2;
inline bool ImPack::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImPack::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImPack::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImPack::clear_content() {
  if (content_ != NULL) content_->::im::ImPackContent::Clear();
  clear_has_content();
}
inline const ::im::ImPackContent& ImPack::content() const {
  return content_ != NULL ? *content_ : *default_instance_->content_;
}
inline ::im::ImPackContent* ImPack::mutable_content() {
  set_has_content();
  if (content_ == NULL) content_ = new ::im::ImPackContent;
  return content_;
}
inline ::im::ImPackContent* ImPack::release_content() {
  clear_has_content();
  ::im::ImPackContent* temp = content_;
  content_ = NULL;
  return temp;
}
inline void ImPack::set_allocated_content(::im::ImPackContent* content) {
  delete content_;
  content_ = content;
  if (content) {
    set_has_content();
  } else {
    clear_has_content();
  }
}

// optional int32 ts = 3;
inline bool ImPack::has_ts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImPack::set_has_ts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImPack::clear_has_ts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImPack::clear_ts() {
  ts_ = 0;
  clear_has_ts();
}
inline ::google::protobuf::int32 ImPack::ts() const {
  return ts_;
}
inline void ImPack::set_ts(::google::protobuf::int32 value) {
  set_has_ts();
  ts_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace im

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::im::ImMsgType>() {
  return ::im::ImMsgType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::im::ImMsgLogicType>() {
  return ::im::ImMsgLogicType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::im::ImPackType>() {
  return ::im::ImPackType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_im_2eproto__INCLUDED
