// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: im.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "im.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace im {

namespace {

const ::google::protobuf::Descriptor* ImTouch_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ImTouch_reflection_ = NULL;
const ::google::protobuf::Descriptor* ImTouchResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ImTouchResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ImMsg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ImMsg_reflection_ = NULL;
const ::google::protobuf::Descriptor* ImMsgAck_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ImMsgAck_reflection_ = NULL;
const ::google::protobuf::Descriptor* ImAuthRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ImAuthRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* ImAuthResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ImAuthResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ImPackContent_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ImPackContent_reflection_ = NULL;
const ::google::protobuf::Descriptor* ImPack_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ImPack_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ImMsgType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ImMsgLogicType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ImPackType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_im_2eproto() {
  protobuf_AddDesc_im_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "im.proto");
  GOOGLE_CHECK(file != NULL);
  ImTouch_descriptor_ = file->message_type(0);
  static const int ImTouch_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImTouch, uid_),
  };
  ImTouch_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ImTouch_descriptor_,
      ImTouch::default_instance_,
      ImTouch_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImTouch, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImTouch, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ImTouch));
  ImTouchResponse_descriptor_ = file->message_type(1);
  static const int ImTouchResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImTouchResponse, uid_),
  };
  ImTouchResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ImTouchResponse_descriptor_,
      ImTouchResponse::default_instance_,
      ImTouchResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImTouchResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImTouchResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ImTouchResponse));
  ImMsg_descriptor_ = file->message_type(2);
  static const int ImMsg_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImMsg, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImMsg, seq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImMsg, target_uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImMsg, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImMsg, msg_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImMsg, points_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImMsg, timeout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImMsg, text_content_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImMsg, pic_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImMsg, vid_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImMsg, loc_word_),
  };
  ImMsg_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ImMsg_descriptor_,
      ImMsg::default_instance_,
      ImMsg_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImMsg, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImMsg, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ImMsg));
  ImMsgAck_descriptor_ = file->message_type(3);
  static const int ImMsgAck_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImMsgAck, msg_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImMsgAck, seq_),
  };
  ImMsgAck_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ImMsgAck_descriptor_,
      ImMsgAck::default_instance_,
      ImMsgAck_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImMsgAck, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImMsgAck, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ImMsgAck));
  ImAuthRequest_descriptor_ = file->message_type(4);
  static const int ImAuthRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImAuthRequest, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImAuthRequest, token_),
  };
  ImAuthRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ImAuthRequest_descriptor_,
      ImAuthRequest::default_instance_,
      ImAuthRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImAuthRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImAuthRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ImAuthRequest));
  ImAuthResponse_descriptor_ = file->message_type(5);
  static const int ImAuthResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImAuthResponse, token_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImAuthResponse, auth_success_),
  };
  ImAuthResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ImAuthResponse_descriptor_,
      ImAuthResponse::default_instance_,
      ImAuthResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImAuthResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImAuthResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ImAuthResponse));
  ImPackContent_descriptor_ = file->message_type(6);
  static const int ImPackContent_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImPackContent, touch_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImPackContent, touch_rep_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImPackContent, msg_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImPackContent, msg_ack_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImPackContent, auth_req_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImPackContent, auth_rep_),
  };
  ImPackContent_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ImPackContent_descriptor_,
      ImPackContent::default_instance_,
      ImPackContent_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImPackContent, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImPackContent, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ImPackContent));
  ImPack_descriptor_ = file->message_type(7);
  static const int ImPack_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImPack, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImPack, content_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImPack, ts_),
  };
  ImPack_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ImPack_descriptor_,
      ImPack::default_instance_,
      ImPack_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImPack, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImPack, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ImPack));
  ImMsgType_descriptor_ = file->enum_type(0);
  ImMsgLogicType_descriptor_ = file->enum_type(1);
  ImPackType_descriptor_ = file->enum_type(2);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_im_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ImTouch_descriptor_, &ImTouch::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ImTouchResponse_descriptor_, &ImTouchResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ImMsg_descriptor_, &ImMsg::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ImMsgAck_descriptor_, &ImMsgAck::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ImAuthRequest_descriptor_, &ImAuthRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ImAuthResponse_descriptor_, &ImAuthResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ImPackContent_descriptor_, &ImPackContent::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ImPack_descriptor_, &ImPack::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_im_2eproto() {
  delete ImTouch::default_instance_;
  delete ImTouch_reflection_;
  delete ImTouchResponse::default_instance_;
  delete ImTouchResponse_reflection_;
  delete ImMsg::default_instance_;
  delete ImMsg_reflection_;
  delete ImMsgAck::default_instance_;
  delete ImMsgAck_reflection_;
  delete ImAuthRequest::default_instance_;
  delete ImAuthRequest_reflection_;
  delete ImAuthResponse::default_instance_;
  delete ImAuthResponse_reflection_;
  delete ImPackContent::default_instance_;
  delete ImPackContent_reflection_;
  delete ImPack::default_instance_;
  delete ImPack_reflection_;
}

void protobuf_AddDesc_im_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\010im.proto\022\002im\"\026\n\007ImTouch\022\013\n\003uid\030\001 \002(\005\"\036"
    "\n\017ImTouchResponse\022\013\n\003uid\030\001 \002(\005\"\320\001\n\005ImMsg"
    "\022\013\n\003uid\030\001 \002(\005\022\013\n\003seq\030\002 \002(\005\022\022\n\ntarget_uid"
    "\030\003 \003(\005\022 \n\004type\030\004 \002(\0162\022.im.ImMsgLogicType"
    "\022\016\n\006msg_id\030\005 \001(\014\022\016\n\006points\030\006 \001(\002\022\017\n\007time"
    "out\030\007 \001(\005\022\024\n\014text_content\030\010 \001(\014\022\016\n\006pic_i"
    "d\030\t \001(\t\022\016\n\006vid_id\030\n \001(\t\022\020\n\010loc_word\030\013 \001("
    "\014\"\'\n\010ImMsgAck\022\016\n\006msg_id\030\001 \001(\014\022\013\n\003seq\030\002 \002"
    "(\005\"+\n\rImAuthRequest\022\013\n\003uid\030\001 \002(\005\022\r\n\005toke"
    "n\030\002 \002(\t\"5\n\016ImAuthResponse\022\r\n\005token\030\001 \002(\t"
    "\022\024\n\014auth_success\030\002 \002(\010\"\325\001\n\rImPackContent"
    "\022\032\n\005touch\030\001 \001(\0132\013.im.ImTouch\022&\n\ttouch_re"
    "p\030\002 \001(\0132\023.im.ImTouchResponse\022\026\n\003msg\030\003 \001("
    "\0132\t.im.ImMsg\022\035\n\007msg_ack\030\004 \001(\0132\014.im.ImMsg"
    "Ack\022#\n\010auth_req\030\005 \001(\0132\021.im.ImAuthRequest"
    "\022$\n\010auth_rep\030\006 \001(\0132\022.im.ImAuthResponse\"V"
    "\n\006ImPack\022\034\n\004type\030\001 \002(\0162\016.im.ImPackType\022\""
    "\n\007content\030\002 \002(\0132\021.im.ImPackContent\022\n\n\002ts"
    "\030\003 \001(\005*/\n\tImMsgType\022\n\n\006IM_TXT\020\001\022\n\n\006IM_PI"
    "C\020\002\022\n\n\006IM_VDO\020\003*1\n\016ImMsgLogicType\022\016\n\nIM_"
    "REQUEST\020\001\022\017\n\013IM_RESPONSE\020\002*z\n\nImPackType"
    "\022\r\n\tIM_UNKNOW\020\000\022\014\n\010IM_TOUCH\020\001\022\020\n\014IM_TOUC"
    "H_ACK\020\002\022\n\n\006IM_MSG\020\003\022\016\n\nIM_MSG_ACK\020\004\022\013\n\007I"
    "M_AUTH\020\005\022\024\n\020IM_AUTH_RESPONSE\020\006", 950);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "im.proto", &protobuf_RegisterTypes);
  ImTouch::default_instance_ = new ImTouch();
  ImTouchResponse::default_instance_ = new ImTouchResponse();
  ImMsg::default_instance_ = new ImMsg();
  ImMsgAck::default_instance_ = new ImMsgAck();
  ImAuthRequest::default_instance_ = new ImAuthRequest();
  ImAuthResponse::default_instance_ = new ImAuthResponse();
  ImPackContent::default_instance_ = new ImPackContent();
  ImPack::default_instance_ = new ImPack();
  ImTouch::default_instance_->InitAsDefaultInstance();
  ImTouchResponse::default_instance_->InitAsDefaultInstance();
  ImMsg::default_instance_->InitAsDefaultInstance();
  ImMsgAck::default_instance_->InitAsDefaultInstance();
  ImAuthRequest::default_instance_->InitAsDefaultInstance();
  ImAuthResponse::default_instance_->InitAsDefaultInstance();
  ImPackContent::default_instance_->InitAsDefaultInstance();
  ImPack::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_im_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_im_2eproto {
  StaticDescriptorInitializer_im_2eproto() {
    protobuf_AddDesc_im_2eproto();
  }
} static_descriptor_initializer_im_2eproto_;
const ::google::protobuf::EnumDescriptor* ImMsgType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImMsgType_descriptor_;
}
bool ImMsgType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ImMsgLogicType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImMsgLogicType_descriptor_;
}
bool ImMsgLogicType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ImPackType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImPackType_descriptor_;
}
bool ImPackType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int ImTouch::kUidFieldNumber;
#endif  // !_MSC_VER

ImTouch::ImTouch()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ImTouch::InitAsDefaultInstance() {
}

ImTouch::ImTouch(const ImTouch& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ImTouch::SharedCtor() {
  _cached_size_ = 0;
  uid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ImTouch::~ImTouch() {
  SharedDtor();
}

void ImTouch::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ImTouch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ImTouch::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImTouch_descriptor_;
}

const ImTouch& ImTouch::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_im_2eproto();
  return *default_instance_;
}

ImTouch* ImTouch::default_instance_ = NULL;

ImTouch* ImTouch::New() const {
  return new ImTouch;
}

void ImTouch::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ImTouch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 uid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ImTouch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->uid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ImTouch::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 uid = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->uid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ImTouch::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->uid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImTouch::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ImTouch* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ImTouch*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ImTouch::MergeFrom(const ImTouch& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ImTouch::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ImTouch::CopyFrom(const ImTouch& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImTouch::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ImTouch::Swap(ImTouch* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ImTouch::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ImTouch_descriptor_;
  metadata.reflection = ImTouch_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ImTouchResponse::kUidFieldNumber;
#endif  // !_MSC_VER

ImTouchResponse::ImTouchResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ImTouchResponse::InitAsDefaultInstance() {
}

ImTouchResponse::ImTouchResponse(const ImTouchResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ImTouchResponse::SharedCtor() {
  _cached_size_ = 0;
  uid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ImTouchResponse::~ImTouchResponse() {
  SharedDtor();
}

void ImTouchResponse::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ImTouchResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ImTouchResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImTouchResponse_descriptor_;
}

const ImTouchResponse& ImTouchResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_im_2eproto();
  return *default_instance_;
}

ImTouchResponse* ImTouchResponse::default_instance_ = NULL;

ImTouchResponse* ImTouchResponse::New() const {
  return new ImTouchResponse;
}

void ImTouchResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ImTouchResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 uid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ImTouchResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->uid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ImTouchResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 uid = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->uid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ImTouchResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->uid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImTouchResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ImTouchResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ImTouchResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ImTouchResponse::MergeFrom(const ImTouchResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ImTouchResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ImTouchResponse::CopyFrom(const ImTouchResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImTouchResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ImTouchResponse::Swap(ImTouchResponse* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ImTouchResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ImTouchResponse_descriptor_;
  metadata.reflection = ImTouchResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ImMsg::kUidFieldNumber;
const int ImMsg::kSeqFieldNumber;
const int ImMsg::kTargetUidFieldNumber;
const int ImMsg::kTypeFieldNumber;
const int ImMsg::kMsgIdFieldNumber;
const int ImMsg::kPointsFieldNumber;
const int ImMsg::kTimeoutFieldNumber;
const int ImMsg::kTextContentFieldNumber;
const int ImMsg::kPicIdFieldNumber;
const int ImMsg::kVidIdFieldNumber;
const int ImMsg::kLocWordFieldNumber;
#endif  // !_MSC_VER

ImMsg::ImMsg()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ImMsg::InitAsDefaultInstance() {
}

ImMsg::ImMsg(const ImMsg& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ImMsg::SharedCtor() {
  _cached_size_ = 0;
  uid_ = 0;
  seq_ = 0;
  type_ = 1;
  msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  points_ = 0;
  timeout_ = 0;
  text_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  pic_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  vid_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  loc_word_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ImMsg::~ImMsg() {
  SharedDtor();
}

void ImMsg::SharedDtor() {
  if (msg_id_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_id_;
  }
  if (text_content_ != &::google::protobuf::internal::kEmptyString) {
    delete text_content_;
  }
  if (pic_id_ != &::google::protobuf::internal::kEmptyString) {
    delete pic_id_;
  }
  if (vid_id_ != &::google::protobuf::internal::kEmptyString) {
    delete vid_id_;
  }
  if (loc_word_ != &::google::protobuf::internal::kEmptyString) {
    delete loc_word_;
  }
  if (this != default_instance_) {
  }
}

void ImMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ImMsg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImMsg_descriptor_;
}

const ImMsg& ImMsg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_im_2eproto();
  return *default_instance_;
}

ImMsg* ImMsg::default_instance_ = NULL;

ImMsg* ImMsg::New() const {
  return new ImMsg;
}

void ImMsg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = 0;
    seq_ = 0;
    type_ = 1;
    if (has_msg_id()) {
      if (msg_id_ != &::google::protobuf::internal::kEmptyString) {
        msg_id_->clear();
      }
    }
    points_ = 0;
    timeout_ = 0;
    if (has_text_content()) {
      if (text_content_ != &::google::protobuf::internal::kEmptyString) {
        text_content_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_pic_id()) {
      if (pic_id_ != &::google::protobuf::internal::kEmptyString) {
        pic_id_->clear();
      }
    }
    if (has_vid_id()) {
      if (vid_id_ != &::google::protobuf::internal::kEmptyString) {
        vid_id_->clear();
      }
    }
    if (has_loc_word()) {
      if (loc_word_ != &::google::protobuf::internal::kEmptyString) {
        loc_word_->clear();
      }
    }
  }
  target_uid_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ImMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 uid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_seq;
        break;
      }

      // required int32 seq = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_seq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_target_uid;
        break;
      }

      // repeated int32 target_uid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_uid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_target_uid())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_target_uid())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_target_uid;
        if (input->ExpectTag(32)) goto parse_type;
        break;
      }

      // required .im.ImMsgLogicType type = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::im::ImMsgLogicType_IsValid(value)) {
            set_type(static_cast< ::im::ImMsgLogicType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_msg_id;
        break;
      }

      // optional bytes msg_id = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_msg_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_msg_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_points;
        break;
      }

      // optional float points = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_points:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &points_)));
          set_has_points();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_timeout;
        break;
      }

      // optional int32 timeout = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_timeout:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &timeout_)));
          set_has_timeout();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_text_content;
        break;
      }

      // optional bytes text_content = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_text_content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_text_content()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_pic_id;
        break;
      }

      // optional string pic_id = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pic_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pic_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->pic_id().data(), this->pic_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_vid_id;
        break;
      }

      // optional string vid_id = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_vid_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vid_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->vid_id().data(), this->vid_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_loc_word;
        break;
      }

      // optional bytes loc_word = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_loc_word:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_loc_word()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ImMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->uid(), output);
  }

  // required int32 seq = 2;
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->seq(), output);
  }

  // repeated int32 target_uid = 3;
  for (int i = 0; i < this->target_uid_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->target_uid(i), output);
  }

  // required .im.ImMsgLogicType type = 4;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->type(), output);
  }

  // optional bytes msg_id = 5;
  if (has_msg_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->msg_id(), output);
  }

  // optional float points = 6;
  if (has_points()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->points(), output);
  }

  // optional int32 timeout = 7;
  if (has_timeout()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->timeout(), output);
  }

  // optional bytes text_content = 8;
  if (has_text_content()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      8, this->text_content(), output);
  }

  // optional string pic_id = 9;
  if (has_pic_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pic_id().data(), this->pic_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->pic_id(), output);
  }

  // optional string vid_id = 10;
  if (has_vid_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->vid_id().data(), this->vid_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->vid_id(), output);
  }

  // optional bytes loc_word = 11;
  if (has_loc_word()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      11, this->loc_word(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ImMsg::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 uid = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->uid(), target);
  }

  // required int32 seq = 2;
  if (has_seq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->seq(), target);
  }

  // repeated int32 target_uid = 3;
  for (int i = 0; i < this->target_uid_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(3, this->target_uid(i), target);
  }

  // required .im.ImMsgLogicType type = 4;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->type(), target);
  }

  // optional bytes msg_id = 5;
  if (has_msg_id()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->msg_id(), target);
  }

  // optional float points = 6;
  if (has_points()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->points(), target);
  }

  // optional int32 timeout = 7;
  if (has_timeout()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->timeout(), target);
  }

  // optional bytes text_content = 8;
  if (has_text_content()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        8, this->text_content(), target);
  }

  // optional string pic_id = 9;
  if (has_pic_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pic_id().data(), this->pic_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->pic_id(), target);
  }

  // optional string vid_id = 10;
  if (has_vid_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->vid_id().data(), this->vid_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->vid_id(), target);
  }

  // optional bytes loc_word = 11;
  if (has_loc_word()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        11, this->loc_word(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ImMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->uid());
    }

    // required int32 seq = 2;
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seq());
    }

    // required .im.ImMsgLogicType type = 4;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional bytes msg_id = 5;
    if (has_msg_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->msg_id());
    }

    // optional float points = 6;
    if (has_points()) {
      total_size += 1 + 4;
    }

    // optional int32 timeout = 7;
    if (has_timeout()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->timeout());
    }

    // optional bytes text_content = 8;
    if (has_text_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->text_content());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string pic_id = 9;
    if (has_pic_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pic_id());
    }

    // optional string vid_id = 10;
    if (has_vid_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->vid_id());
    }

    // optional bytes loc_word = 11;
    if (has_loc_word()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->loc_word());
    }

  }
  // repeated int32 target_uid = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->target_uid_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->target_uid(i));
    }
    total_size += 1 * this->target_uid_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImMsg::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ImMsg* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ImMsg*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ImMsg::MergeFrom(const ImMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  target_uid_.MergeFrom(from.target_uid_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_seq()) {
      set_seq(from.seq());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_msg_id()) {
      set_msg_id(from.msg_id());
    }
    if (from.has_points()) {
      set_points(from.points());
    }
    if (from.has_timeout()) {
      set_timeout(from.timeout());
    }
    if (from.has_text_content()) {
      set_text_content(from.text_content());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_pic_id()) {
      set_pic_id(from.pic_id());
    }
    if (from.has_vid_id()) {
      set_vid_id(from.vid_id());
    }
    if (from.has_loc_word()) {
      set_loc_word(from.loc_word());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ImMsg::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ImMsg::CopyFrom(const ImMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImMsg::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000b) != 0x0000000b) return false;

  return true;
}

void ImMsg::Swap(ImMsg* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(seq_, other->seq_);
    target_uid_.Swap(&other->target_uid_);
    std::swap(type_, other->type_);
    std::swap(msg_id_, other->msg_id_);
    std::swap(points_, other->points_);
    std::swap(timeout_, other->timeout_);
    std::swap(text_content_, other->text_content_);
    std::swap(pic_id_, other->pic_id_);
    std::swap(vid_id_, other->vid_id_);
    std::swap(loc_word_, other->loc_word_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ImMsg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ImMsg_descriptor_;
  metadata.reflection = ImMsg_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ImMsgAck::kMsgIdFieldNumber;
const int ImMsgAck::kSeqFieldNumber;
#endif  // !_MSC_VER

ImMsgAck::ImMsgAck()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ImMsgAck::InitAsDefaultInstance() {
}

ImMsgAck::ImMsgAck(const ImMsgAck& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ImMsgAck::SharedCtor() {
  _cached_size_ = 0;
  msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  seq_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ImMsgAck::~ImMsgAck() {
  SharedDtor();
}

void ImMsgAck::SharedDtor() {
  if (msg_id_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_id_;
  }
  if (this != default_instance_) {
  }
}

void ImMsgAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ImMsgAck::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImMsgAck_descriptor_;
}

const ImMsgAck& ImMsgAck::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_im_2eproto();
  return *default_instance_;
}

ImMsgAck* ImMsgAck::default_instance_ = NULL;

ImMsgAck* ImMsgAck::New() const {
  return new ImMsgAck;
}

void ImMsgAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_msg_id()) {
      if (msg_id_ != &::google::protobuf::internal::kEmptyString) {
        msg_id_->clear();
      }
    }
    seq_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ImMsgAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes msg_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_msg_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_seq;
        break;
      }

      // required int32 seq = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_seq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ImMsgAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes msg_id = 1;
  if (has_msg_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->msg_id(), output);
  }

  // required int32 seq = 2;
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->seq(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ImMsgAck::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes msg_id = 1;
  if (has_msg_id()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->msg_id(), target);
  }

  // required int32 seq = 2;
  if (has_seq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->seq(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ImMsgAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes msg_id = 1;
    if (has_msg_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->msg_id());
    }

    // required int32 seq = 2;
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seq());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImMsgAck::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ImMsgAck* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ImMsgAck*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ImMsgAck::MergeFrom(const ImMsgAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msg_id()) {
      set_msg_id(from.msg_id());
    }
    if (from.has_seq()) {
      set_seq(from.seq());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ImMsgAck::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ImMsgAck::CopyFrom(const ImMsgAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImMsgAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void ImMsgAck::Swap(ImMsgAck* other) {
  if (other != this) {
    std::swap(msg_id_, other->msg_id_);
    std::swap(seq_, other->seq_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ImMsgAck::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ImMsgAck_descriptor_;
  metadata.reflection = ImMsgAck_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ImAuthRequest::kUidFieldNumber;
const int ImAuthRequest::kTokenFieldNumber;
#endif  // !_MSC_VER

ImAuthRequest::ImAuthRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ImAuthRequest::InitAsDefaultInstance() {
}

ImAuthRequest::ImAuthRequest(const ImAuthRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ImAuthRequest::SharedCtor() {
  _cached_size_ = 0;
  uid_ = 0;
  token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ImAuthRequest::~ImAuthRequest() {
  SharedDtor();
}

void ImAuthRequest::SharedDtor() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (this != default_instance_) {
  }
}

void ImAuthRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ImAuthRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImAuthRequest_descriptor_;
}

const ImAuthRequest& ImAuthRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_im_2eproto();
  return *default_instance_;
}

ImAuthRequest* ImAuthRequest::default_instance_ = NULL;

ImAuthRequest* ImAuthRequest::New() const {
  return new ImAuthRequest;
}

void ImAuthRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = 0;
    if (has_token()) {
      if (token_ != &::google::protobuf::internal::kEmptyString) {
        token_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ImAuthRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 uid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_token;
        break;
      }

      // required string token = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_token:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_token()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->token().data(), this->token().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ImAuthRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->uid(), output);
  }

  // required string token = 2;
  if (has_token()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->token().data(), this->token().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->token(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ImAuthRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 uid = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->uid(), target);
  }

  // required string token = 2;
  if (has_token()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->token().data(), this->token().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->token(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ImAuthRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->uid());
    }

    // required string token = 2;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->token());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImAuthRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ImAuthRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ImAuthRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ImAuthRequest::MergeFrom(const ImAuthRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_token()) {
      set_token(from.token());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ImAuthRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ImAuthRequest::CopyFrom(const ImAuthRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImAuthRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ImAuthRequest::Swap(ImAuthRequest* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(token_, other->token_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ImAuthRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ImAuthRequest_descriptor_;
  metadata.reflection = ImAuthRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ImAuthResponse::kTokenFieldNumber;
const int ImAuthResponse::kAuthSuccessFieldNumber;
#endif  // !_MSC_VER

ImAuthResponse::ImAuthResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ImAuthResponse::InitAsDefaultInstance() {
}

ImAuthResponse::ImAuthResponse(const ImAuthResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ImAuthResponse::SharedCtor() {
  _cached_size_ = 0;
  token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  auth_success_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ImAuthResponse::~ImAuthResponse() {
  SharedDtor();
}

void ImAuthResponse::SharedDtor() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (this != default_instance_) {
  }
}

void ImAuthResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ImAuthResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImAuthResponse_descriptor_;
}

const ImAuthResponse& ImAuthResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_im_2eproto();
  return *default_instance_;
}

ImAuthResponse* ImAuthResponse::default_instance_ = NULL;

ImAuthResponse* ImAuthResponse::New() const {
  return new ImAuthResponse;
}

void ImAuthResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_token()) {
      if (token_ != &::google::protobuf::internal::kEmptyString) {
        token_->clear();
      }
    }
    auth_success_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ImAuthResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string token = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_token()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->token().data(), this->token().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_auth_success;
        break;
      }

      // required bool auth_success = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_auth_success:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &auth_success_)));
          set_has_auth_success();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ImAuthResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string token = 1;
  if (has_token()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->token().data(), this->token().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->token(), output);
  }

  // required bool auth_success = 2;
  if (has_auth_success()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->auth_success(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ImAuthResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string token = 1;
  if (has_token()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->token().data(), this->token().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->token(), target);
  }

  // required bool auth_success = 2;
  if (has_auth_success()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->auth_success(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ImAuthResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string token = 1;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->token());
    }

    // required bool auth_success = 2;
    if (has_auth_success()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImAuthResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ImAuthResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ImAuthResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ImAuthResponse::MergeFrom(const ImAuthResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_token()) {
      set_token(from.token());
    }
    if (from.has_auth_success()) {
      set_auth_success(from.auth_success());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ImAuthResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ImAuthResponse::CopyFrom(const ImAuthResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImAuthResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ImAuthResponse::Swap(ImAuthResponse* other) {
  if (other != this) {
    std::swap(token_, other->token_);
    std::swap(auth_success_, other->auth_success_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ImAuthResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ImAuthResponse_descriptor_;
  metadata.reflection = ImAuthResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ImPackContent::kTouchFieldNumber;
const int ImPackContent::kTouchRepFieldNumber;
const int ImPackContent::kMsgFieldNumber;
const int ImPackContent::kMsgAckFieldNumber;
const int ImPackContent::kAuthReqFieldNumber;
const int ImPackContent::kAuthRepFieldNumber;
#endif  // !_MSC_VER

ImPackContent::ImPackContent()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ImPackContent::InitAsDefaultInstance() {
  touch_ = const_cast< ::im::ImTouch*>(&::im::ImTouch::default_instance());
  touch_rep_ = const_cast< ::im::ImTouchResponse*>(&::im::ImTouchResponse::default_instance());
  msg_ = const_cast< ::im::ImMsg*>(&::im::ImMsg::default_instance());
  msg_ack_ = const_cast< ::im::ImMsgAck*>(&::im::ImMsgAck::default_instance());
  auth_req_ = const_cast< ::im::ImAuthRequest*>(&::im::ImAuthRequest::default_instance());
  auth_rep_ = const_cast< ::im::ImAuthResponse*>(&::im::ImAuthResponse::default_instance());
}

ImPackContent::ImPackContent(const ImPackContent& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ImPackContent::SharedCtor() {
  _cached_size_ = 0;
  touch_ = NULL;
  touch_rep_ = NULL;
  msg_ = NULL;
  msg_ack_ = NULL;
  auth_req_ = NULL;
  auth_rep_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ImPackContent::~ImPackContent() {
  SharedDtor();
}

void ImPackContent::SharedDtor() {
  if (this != default_instance_) {
    delete touch_;
    delete touch_rep_;
    delete msg_;
    delete msg_ack_;
    delete auth_req_;
    delete auth_rep_;
  }
}

void ImPackContent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ImPackContent::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImPackContent_descriptor_;
}

const ImPackContent& ImPackContent::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_im_2eproto();
  return *default_instance_;
}

ImPackContent* ImPackContent::default_instance_ = NULL;

ImPackContent* ImPackContent::New() const {
  return new ImPackContent;
}

void ImPackContent::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_touch()) {
      if (touch_ != NULL) touch_->::im::ImTouch::Clear();
    }
    if (has_touch_rep()) {
      if (touch_rep_ != NULL) touch_rep_->::im::ImTouchResponse::Clear();
    }
    if (has_msg()) {
      if (msg_ != NULL) msg_->::im::ImMsg::Clear();
    }
    if (has_msg_ack()) {
      if (msg_ack_ != NULL) msg_ack_->::im::ImMsgAck::Clear();
    }
    if (has_auth_req()) {
      if (auth_req_ != NULL) auth_req_->::im::ImAuthRequest::Clear();
    }
    if (has_auth_rep()) {
      if (auth_rep_ != NULL) auth_rep_->::im::ImAuthResponse::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ImPackContent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .im.ImTouch touch = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_touch()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_touch_rep;
        break;
      }

      // optional .im.ImTouchResponse touch_rep = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_touch_rep:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_touch_rep()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_msg;
        break;
      }

      // optional .im.ImMsg msg = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_msg_ack;
        break;
      }

      // optional .im.ImMsgAck msg_ack = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_msg_ack:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_ack()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_auth_req;
        break;
      }

      // optional .im.ImAuthRequest auth_req = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_auth_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_auth_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_auth_rep;
        break;
      }

      // optional .im.ImAuthResponse auth_rep = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_auth_rep:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_auth_rep()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ImPackContent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .im.ImTouch touch = 1;
  if (has_touch()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->touch(), output);
  }

  // optional .im.ImTouchResponse touch_rep = 2;
  if (has_touch_rep()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->touch_rep(), output);
  }

  // optional .im.ImMsg msg = 3;
  if (has_msg()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->msg(), output);
  }

  // optional .im.ImMsgAck msg_ack = 4;
  if (has_msg_ack()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->msg_ack(), output);
  }

  // optional .im.ImAuthRequest auth_req = 5;
  if (has_auth_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->auth_req(), output);
  }

  // optional .im.ImAuthResponse auth_rep = 6;
  if (has_auth_rep()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->auth_rep(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ImPackContent::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .im.ImTouch touch = 1;
  if (has_touch()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->touch(), target);
  }

  // optional .im.ImTouchResponse touch_rep = 2;
  if (has_touch_rep()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->touch_rep(), target);
  }

  // optional .im.ImMsg msg = 3;
  if (has_msg()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->msg(), target);
  }

  // optional .im.ImMsgAck msg_ack = 4;
  if (has_msg_ack()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->msg_ack(), target);
  }

  // optional .im.ImAuthRequest auth_req = 5;
  if (has_auth_req()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->auth_req(), target);
  }

  // optional .im.ImAuthResponse auth_rep = 6;
  if (has_auth_rep()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->auth_rep(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ImPackContent::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .im.ImTouch touch = 1;
    if (has_touch()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->touch());
    }

    // optional .im.ImTouchResponse touch_rep = 2;
    if (has_touch_rep()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->touch_rep());
    }

    // optional .im.ImMsg msg = 3;
    if (has_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg());
    }

    // optional .im.ImMsgAck msg_ack = 4;
    if (has_msg_ack()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_ack());
    }

    // optional .im.ImAuthRequest auth_req = 5;
    if (has_auth_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->auth_req());
    }

    // optional .im.ImAuthResponse auth_rep = 6;
    if (has_auth_rep()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->auth_rep());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImPackContent::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ImPackContent* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ImPackContent*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ImPackContent::MergeFrom(const ImPackContent& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_touch()) {
      mutable_touch()->::im::ImTouch::MergeFrom(from.touch());
    }
    if (from.has_touch_rep()) {
      mutable_touch_rep()->::im::ImTouchResponse::MergeFrom(from.touch_rep());
    }
    if (from.has_msg()) {
      mutable_msg()->::im::ImMsg::MergeFrom(from.msg());
    }
    if (from.has_msg_ack()) {
      mutable_msg_ack()->::im::ImMsgAck::MergeFrom(from.msg_ack());
    }
    if (from.has_auth_req()) {
      mutable_auth_req()->::im::ImAuthRequest::MergeFrom(from.auth_req());
    }
    if (from.has_auth_rep()) {
      mutable_auth_rep()->::im::ImAuthResponse::MergeFrom(from.auth_rep());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ImPackContent::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ImPackContent::CopyFrom(const ImPackContent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImPackContent::IsInitialized() const {

  if (has_touch()) {
    if (!this->touch().IsInitialized()) return false;
  }
  if (has_touch_rep()) {
    if (!this->touch_rep().IsInitialized()) return false;
  }
  if (has_msg()) {
    if (!this->msg().IsInitialized()) return false;
  }
  if (has_msg_ack()) {
    if (!this->msg_ack().IsInitialized()) return false;
  }
  if (has_auth_req()) {
    if (!this->auth_req().IsInitialized()) return false;
  }
  if (has_auth_rep()) {
    if (!this->auth_rep().IsInitialized()) return false;
  }
  return true;
}

void ImPackContent::Swap(ImPackContent* other) {
  if (other != this) {
    std::swap(touch_, other->touch_);
    std::swap(touch_rep_, other->touch_rep_);
    std::swap(msg_, other->msg_);
    std::swap(msg_ack_, other->msg_ack_);
    std::swap(auth_req_, other->auth_req_);
    std::swap(auth_rep_, other->auth_rep_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ImPackContent::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ImPackContent_descriptor_;
  metadata.reflection = ImPackContent_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ImPack::kTypeFieldNumber;
const int ImPack::kContentFieldNumber;
const int ImPack::kTsFieldNumber;
#endif  // !_MSC_VER

ImPack::ImPack()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ImPack::InitAsDefaultInstance() {
  content_ = const_cast< ::im::ImPackContent*>(&::im::ImPackContent::default_instance());
}

ImPack::ImPack(const ImPack& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ImPack::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  content_ = NULL;
  ts_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ImPack::~ImPack() {
  SharedDtor();
}

void ImPack::SharedDtor() {
  if (this != default_instance_) {
    delete content_;
  }
}

void ImPack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ImPack::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImPack_descriptor_;
}

const ImPack& ImPack::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_im_2eproto();
  return *default_instance_;
}

ImPack* ImPack::default_instance_ = NULL;

ImPack* ImPack::New() const {
  return new ImPack;
}

void ImPack::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_content()) {
      if (content_ != NULL) content_->::im::ImPackContent::Clear();
    }
    ts_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ImPack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .im.ImPackType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::im::ImPackType_IsValid(value)) {
            set_type(static_cast< ::im::ImPackType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_content;
        break;
      }

      // required .im.ImPackContent content = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_content()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_ts;
        break;
      }

      // optional int32 ts = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ts_)));
          set_has_ts();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ImPack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .im.ImPackType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required .im.ImPackContent content = 2;
  if (has_content()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->content(), output);
  }

  // optional int32 ts = 3;
  if (has_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->ts(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ImPack::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .im.ImPackType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // required .im.ImPackContent content = 2;
  if (has_content()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->content(), target);
  }

  // optional int32 ts = 3;
  if (has_ts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->ts(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ImPack::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .im.ImPackType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required .im.ImPackContent content = 2;
    if (has_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->content());
    }

    // optional int32 ts = 3;
    if (has_ts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ts());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImPack::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ImPack* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ImPack*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ImPack::MergeFrom(const ImPack& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_content()) {
      mutable_content()->::im::ImPackContent::MergeFrom(from.content());
    }
    if (from.has_ts()) {
      set_ts(from.ts());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ImPack::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ImPack::CopyFrom(const ImPack& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImPack::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_content()) {
    if (!this->content().IsInitialized()) return false;
  }
  return true;
}

void ImPack::Swap(ImPack* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(content_, other->content_);
    std::swap(ts_, other->ts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ImPack::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ImPack_descriptor_;
  metadata.reflection = ImPack_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace im

// @@protoc_insertion_point(global_scope)
